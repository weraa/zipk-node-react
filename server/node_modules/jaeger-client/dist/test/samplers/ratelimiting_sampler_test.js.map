{"version":3,"sources":["../../../test/samplers/ratelimiting_sampler_test.js"],"names":["describe","it","initialDate","Date","getTime","clock","sinon","useFakeTimers","sampler","RateLimitingSampler","i","assert","isTrue","isSampled","equal","maxTracesPerSecond","isNotOk","ProbabilisticSampler","tags","decision","isFalse","deepEqual","restore","to","throw","otherSampler","isOk","update","limiter"],"mappings":";;AAaA;;AACA;;;;AACA;;;;AACA;;;;;;AAfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAOAA,SAAS,4BAAT,EAAuC,YAAM;AAC3CC,KAAG,8BAAH,EAAmC,YAAM;AACvC,QAAIC,cAAc,IAAIC,IAAJ,CAAS,IAAT,EAAe,CAAf,EAAkB,CAAlB,EAAqBC,OAArB,EAAlB;AACA,QAAIC,QAAQC,gBAAMC,aAAN,CAAoBL,WAApB,CAAZ;AACA,QAAIM,UAAU,IAAIC,8BAAJ,CAAwB,EAAxB,EAA4B,EAA5B,CAAd;AACA,SAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAI,EAApB,EAAwBA,GAAxB,EAA6B;AAC3BC,mBAAOC,MAAP,CAAcJ,QAAQK,SAAR,CAAkB,WAAlB,EAA+B,EAA/B,CAAd,EAAkD,8BAAlD;AACD;;AAEDF,iBAAOG,KAAP,CAAaN,QAAQO,kBAArB,EAAyC,EAAzC;AACAJ,iBAAOK,OAAP,CAAeR,QAAQM,KAAR,CAAc,IAAIG,+BAAJ,CAAyB,GAAzB,CAAd,CAAf;;AAEA,QAAIC,OAAO,EAAX;AACA,QAAIC,WAAWX,QAAQK,SAAR,CAAkB,WAAlB,EAA+BK,IAA/B,CAAf;AACAP,iBAAOS,OAAP,CAAeD,QAAf,EAAyB,+BAAzB;AACAR,iBAAOU,SAAP,CAAiBH,IAAjB,EAAuB,EAAvB,EAA2B,2BAA3B;;AAEAb,YAAQC,gBAAMC,aAAN,CAAoBL,cAAc,IAAlC,CAAR;AACAgB,WAAO,EAAP;AACAC,eAAWX,QAAQK,SAAR,CAAkB,WAAlB,EAA+BK,IAA/B,CAAX;AACAP,iBAAOC,MAAP,CAAcO,QAAd,EAAwB,8BAAxB;AACAR,iBAAOU,SAAP,CAAiBH,IAAjB,EAAuB,EAAE,gBAAgB,cAAlB,EAAkC,iBAAiB,EAAnD,EAAvB;AACAb,UAAMiB,OAAN;AACD,GAtBD;;AAwBArB,KAAG,6DAAH,EAAkE,YAAM;AACtE,sBAAO,YAAM;AACX,UAAIQ,8BAAJ,CAAwB,CAAC,GAAzB;AACD,KAFD,EAEGc,EAFH,CAEMC,KAFN,CAEY,2DAFZ;AAGD,GAJD;;AAMAvB,KAAG,4CAAH,EAAiD,YAAM;AACrD,QAAIO,UAAU,IAAIC,8BAAJ,CAAwB,GAAxB,CAAd;AACA,QAAIgB,eAAe,IAAIhB,8BAAJ,CAAwB,GAAxB,CAAnB;;AAEAE,iBAAOe,IAAP,CAAYlB,QAAQM,KAAR,CAAcW,YAAd,CAAZ;AACD,GALD;;AAOAxB,KAAG,8CAAH,EAAmD,YAAM;AACvD,QAAIC,cAAc,IAAIC,IAAJ,CAAS,IAAT,EAAe,CAAf,EAAkB,CAAlB,EAAqBC,OAArB,EAAlB;AACA,QAAIC,QAAQC,gBAAMC,aAAN,CAAoBL,WAApB,CAAZ;AACA,QAAIM,UAAU,IAAIC,8BAAJ,CAAwB,GAAxB,EAA6B,CAA7B,CAAd;;AAEAE,iBAAOC,MAAP,CAAcJ,QAAQK,SAAR,CAAkB,WAAlB,EAA+B,EAA/B,CAAd,EAAkD,8BAAlD;;AAEAR,YAAQC,gBAAMC,aAAN,CAAoBL,cAAc,KAAlC,CAAR;AACAS,iBAAOC,MAAP,CAAcJ,QAAQK,SAAR,CAAkB,WAAlB,EAA+B,EAA/B,CAAd,EAAkD,8BAAlD;AACAR,UAAMiB,OAAN;AACD,GAVD;;AAYArB,KAAG,4BAAH,EAAiC,YAAM;AACrC,QAAIC,cAAc,IAAIC,IAAJ,CAAS,IAAT,EAAe,CAAf,EAAkB,CAAlB,EAAqBC,OAArB,EAAlB;AACA,QAAIC,QAAQC,gBAAMC,aAAN,CAAoBL,WAApB,CAAZ;AACA,QAAIM,UAAU,IAAIC,8BAAJ,CAAwB,GAAxB,EAA6B,CAA7B,CAAd;;AAEAE,iBAAOC,MAAP,CAAcJ,QAAQK,SAAR,CAAkB,WAAlB,EAA+B,EAA/B,CAAd,EAAkD,8BAAlD;;AAEAF,iBAAOS,OAAP,CAAeZ,QAAQmB,MAAR,CAAe,GAAf,CAAf,EAAoC,gEAApC;AACAhB,iBAAOC,MAAP,CAAcJ,QAAQmB,MAAR,CAAe,GAAf,CAAd,EAAmC,kEAAnC;;AAEAtB,YAAQC,gBAAMC,aAAN,CAAoBL,cAAc,KAAlC,CAAR;AACA,QAAIgB,OAAO,EAAX;AACAP,iBAAOC,MAAP,CAAcJ,QAAQK,SAAR,CAAkB,WAAlB,EAA+BK,IAA/B,CAAd,EAAoD,8BAApD;AACAP,iBAAOU,SAAP,CAAiBH,IAAjB,EAAuB,EAAE,gBAAgB,cAAlB,EAAkC,iBAAiB,CAAnD,EAAvB;AACAP,iBAAOC,MAAP,CAAcJ,QAAQK,SAAR,CAAkB,WAAlB,EAA+B,EAA/B,CAAd,EAAkD,8BAAlD;AACAF,iBAAOS,OAAP,CAAeZ,QAAQK,SAAR,CAAkB,WAAlB,EAA+B,EAA/B,CAAf,EAAmD,+BAAnD;AACAR,UAAMiB,OAAN;AACD,GAjBD;;AAmBArB,KAAG,yDAAH,EAA8D,YAAM;AAClE,QAAI2B,UAAU,IAAInB,8BAAJ,CAAwB,GAAxB,CAAd;AACA,sBAAO,YAAM;AACXmB,cAAQD,MAAR,CAAe,CAAC,GAAhB;AACD,KAFD,EAEGJ,EAFH,CAEMC,KAFN,CAEY,2DAFZ;AAGD,GALD;AAMD,CA3ED","file":"ratelimiting_sampler_test.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport { assert, expect } from 'chai';\nimport ProbabilisticSampler from '../../src/samplers/probabilistic_sampler.js';\nimport RateLimitingSampler from '../../src/samplers/ratelimiting_sampler.js';\nimport sinon from 'sinon';\n\ndescribe('RateLimitingSampler should', () => {\n  it('block after threshold is met', () => {\n    let initialDate = new Date(2011, 9, 1).getTime();\n    let clock = sinon.useFakeTimers(initialDate);\n    let sampler = new RateLimitingSampler(10, 10);\n    for (let i = 0; i < 10; i++) {\n      assert.isTrue(sampler.isSampled('operation', {}), 'expected decision to be true');\n    }\n\n    assert.equal(sampler.maxTracesPerSecond, 10);\n    assert.isNotOk(sampler.equal(new ProbabilisticSampler(0.5)));\n\n    let tags = {};\n    let decision = sampler.isSampled('operation', tags);\n    assert.isFalse(decision, 'expected decision to be false');\n    assert.deepEqual(tags, {}, 'expected tags to be empty');\n\n    clock = sinon.useFakeTimers(initialDate + 1000);\n    tags = {};\n    decision = sampler.isSampled('operation', tags);\n    assert.isTrue(decision, 'expected decision to be true');\n    assert.deepEqual(tags, { 'sampler.type': 'ratelimiting', 'sampler.param': 10 });\n    clock.restore();\n  });\n\n  it('should throw error when initialized with an incorrect value', () => {\n    expect(() => {\n      new RateLimitingSampler(-2.0);\n    }).to.throw('maxTracesPerSecond must be greater than 0.0.  Received -2');\n  });\n\n  it('should equal another rate limiting sampler', () => {\n    let sampler = new RateLimitingSampler(1.0);\n    let otherSampler = new RateLimitingSampler(1.0);\n\n    assert.isOk(sampler.equal(otherSampler));\n  });\n\n  it('work with maxCreditsPerSecond smaller than 1', () => {\n    let initialDate = new Date(2011, 9, 1).getTime();\n    let clock = sinon.useFakeTimers(initialDate);\n    let sampler = new RateLimitingSampler(0.1, 1);\n\n    assert.isTrue(sampler.isSampled('operation', {}), 'expected decision to be true');\n\n    clock = sinon.useFakeTimers(initialDate + 10000);\n    assert.isTrue(sampler.isSampled('operation', {}), 'expected decision to be true');\n    clock.restore();\n  });\n\n  it('should update successfully', () => {\n    let initialDate = new Date(2011, 9, 1).getTime();\n    let clock = sinon.useFakeTimers(initialDate);\n    let sampler = new RateLimitingSampler(1.0, 1);\n\n    assert.isTrue(sampler.isSampled('operation', {}), 'expected decision to be true');\n\n    assert.isFalse(sampler.update(1.0), 'updating using the same maxTracesPerSecond should return false');\n    assert.isTrue(sampler.update(2.0), 'updating using a different maxTracesPerSecond should return true');\n\n    clock = sinon.useFakeTimers(initialDate + 20000);\n    let tags = {};\n    assert.isTrue(sampler.isSampled('operation', tags), 'expected decision to be true');\n    assert.deepEqual(tags, { 'sampler.type': 'ratelimiting', 'sampler.param': 2 });\n    assert.isTrue(sampler.isSampled('operation', {}), 'expected decision to be true');\n    assert.isFalse(sampler.isSampled('operation', {}), 'expected decision to be false');\n    clock.restore();\n  });\n\n  it('should throw error when updated with an incorrect value', () => {\n    let limiter = new RateLimitingSampler(2.0);\n    expect(() => {\n      limiter.update(-2.0);\n    }).to.throw('maxTracesPerSecond must be greater than 0.0.  Received -2');\n  });\n});\n"]}