{"version":3,"sources":["../../src/util.js"],"names":["Utils","text","prefix","indexOf","randint","xorshift","randomint","buf","Buffer","writeUInt32BE","numberValue","Int64","toBuffer","ip","ipl","parts","split","length","i","parseInt","signedLimit","input","counter","charAt","substring","myIp","ifaces","os","networkInterfaces","keys","Object","loop1","iface","j","family","internal","address","obj","newObj","key","hasOwnProperty","dict","tags","value","push","host","port","path","success","error","http","get","res","setEncoding","body","on","chunk","err"],"mappings":"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","file":"util.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport xorshift from 'xorshift';\nimport Int64 from 'node-int64';\nimport os from 'os';\nimport http from 'http';\n\nexport default class Utils {\n  /**\n   * Determines whether a string contains a given prefix.\n   *\n   * @param {string} text - the string for to search for a prefix\n   * @param {string} prefix - the prefix to search for in the text given.\n   * @return {boolean} - boolean representing whether or not the\n   * string contains the prefix.\n   **/\n  static startsWith(text: string, prefix: string): boolean {\n    return text.indexOf(prefix) === 0;\n  }\n\n  /**\n   * Determines whether a string contains a given prefix.\n   *\n   * @return {Buffer}  - returns a buffer representing a random 64 bit\n   * number.\n   **/\n  static getRandom64(): Buffer {\n    let randint = xorshift.randomint();\n    let buf = new Buffer(8);\n    buf.writeUInt32BE(randint[0], 0);\n    buf.writeUInt32BE(randint[1], 4);\n    return buf;\n  }\n\n  /**\n   * @param {string|number} numberValue - a string or number to be encoded\n   * as a 64 bit byte array.\n   * @return {Buffer} - returns a buffer representing the encoded string, or number.\n   **/\n  static encodeInt64(numberValue: any): any {\n    return new Int64(numberValue).toBuffer();\n  }\n\n  /**\n   * @param {string} ip - a string representation of an ip address.\n   * @return {number} - a 32-bit number where each byte represents an\n   * octect of an ip address.\n   **/\n  static ipToInt(ip: string): ?number {\n    let ipl = 0;\n    let parts = ip.split('.');\n    if (parts.length != 4) {\n      return null;\n    }\n\n    for (let i = 0; i < parts.length; i++) {\n      ipl <<= 8;\n      ipl += parseInt(parts[i], 10);\n    }\n\n    let signedLimit = 0x7fffffff;\n    if (ipl > signedLimit) {\n      return (1 << 32) - ipl;\n    }\n    return ipl;\n  }\n\n  /**\n   * @param {string} input - the input for which leading zeros should be removed.\n   * @return {string} - returns the input string without leading zeros.\n   **/\n  static removeLeadingZeros(input: string): string {\n    let counter = 0;\n    let length = input.length - 1;\n    for (let i = 0; i < length; i++) {\n      if (input.charAt(i) === '0') {\n        counter++;\n      } else {\n        break;\n      }\n    }\n\n    return input.substring(counter);\n  }\n\n  static myIp(): string {\n    let myIp = '0.0.0.0';\n    let ifaces = os.networkInterfaces();\n    let keys = Object.keys(ifaces);\n    loop1: for (let i = 0; i < keys.length; i++) {\n      let iface = ifaces[keys[i]];\n      for (let j = 0; j < iface.length; j++) {\n        if (iface[j].family === 'IPv4' && !iface[j].internal) {\n          myIp = iface[j].address;\n          break loop1;\n        }\n      }\n    }\n    return myIp;\n  }\n\n  static clone(obj: any): any {\n    let newObj = {};\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        newObj[key] = obj[key];\n      }\n    }\n\n    return newObj;\n  }\n\n  static convertObjectToTags(dict: any): Array<Tag> {\n    let tags: Array<Tag> = [];\n    for (let key in dict) {\n      let value = dict[key];\n      if (dict.hasOwnProperty(key)) {\n        tags.push({ key: key, value: value });\n      }\n    }\n\n    return tags;\n  }\n\n  static httpGet(host: string, port: number, path: string, success: Function, error: Function) {\n    http\n      .get(\n        {\n          host: host,\n          port: port,\n          path: path,\n        },\n        res => {\n          // explicitly treat incoming data as utf8 (avoids issues with multi-byte chars)\n          res.setEncoding('utf8');\n\n          // incrementally capture the incoming response body\n          let body = '';\n          res.on('data', chunk => {\n            body += chunk;\n          });\n\n          res.on('end', () => {\n            success(body);\n          });\n        }\n      )\n      .on('error', err => {\n        error(err);\n      });\n  }\n}\n"]}