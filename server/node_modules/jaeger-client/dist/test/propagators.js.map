{"version":3,"sources":["../../test/propagators.js"],"names":["constants","describe","it","codec","TextMapCodec","urlEncoding","_decodeURIValue","value","URIError","assert","strictEqual","_decodeValue","contextKey","ctx","SpanContext","fromString","out","inject","baggagePrefix","carrier","extract","deepEqual","baggage","ZipkinB3TextMapCodec","foo","equal","parentIdStr","spanIdStr","traceIdStr","isSampled","isDebug","isNotOk","withStringIds","flags","DEBUG_MASK","SAMPLED_MASK","isUndefined","withBaggageItem"],"mappings":"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","file":"propagators.js","sourcesContent":["// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport { assert } from 'chai';\nimport * as constants from '../src/constants';\nimport TextMapCodec from '../src/propagators/text_map_codec';\nimport ZipkinB3TextMapCodec from '../src/propagators/zipkin_b3_text_map_codec';\nimport SpanContext from '../src/span_context';\n\ndescribe('TextMapCodec', () => {\n  it('should not URL-decode value that has no % meta-characters', () => {\n    let codec = new TextMapCodec({ urlEncoding: true });\n    codec._decodeURIValue = (value: string) => {\n      throw new URIError('fake error');\n    };\n    assert.strictEqual(codec._decodeValue('abc'), 'abc');\n  });\n\n  it('should not throw exception on bad URL-encoded values', () => {\n    let codec = new TextMapCodec({ urlEncoding: true });\n    // this string throws exception when passed to decodeURIComponent\n    assert.strictEqual(codec._decodeValue('%EA'), '%EA');\n  });\n\n  it('should not URL-encode span context', () => {\n    let codec = new TextMapCodec({ urlEncoding: true, contextKey: 'trace-context' });\n    let ctx = SpanContext.fromString('1:1:1:1');\n    let out = {};\n    codec.inject(ctx, out);\n    assert.strictEqual(out['trace-context'], '1:1:1:1');\n  });\n\n  it('should decode baggage', () => {\n    let codec = new TextMapCodec({\n      urlEncoding: true,\n      contextKey: 'trace-context',\n      baggagePrefix: 'baggage-',\n    });\n    let carrier = {\n      'trace-context': '1:1:1:1',\n      'baggage-some-key': 'some-value',\n      'garbage-in': 'garbage-out',\n    };\n    let ctx = codec.extract(carrier);\n    assert.deepEqual(ctx.baggage, { 'some-key': 'some-value' });\n  });\n});\n\ndescribe('ZipkinB3TextMapCodec', () => {\n  it('correctly extract the zipkin headers from a span context', () => {\n    let codec = new ZipkinB3TextMapCodec({ urlEncoding: true });\n\n    let carrier = {\n      'x-b3-parentspanid': '123abc',\n      'x-b3-spanid': 'aaafff',\n      'x-b3-traceid': '789fed',\n      'x-b3-sampled': '1',\n      'x-b3-flags': '1',\n      foo: 'bar',\n    };\n\n    let ctx = codec.extract(carrier);\n    assert.equal(ctx.parentIdStr, '123abc');\n    assert.equal(ctx.spanIdStr, 'aaafff');\n    assert.equal(ctx.traceIdStr, '789fed');\n    assert.equal(ctx.isSampled(), true);\n    assert.equal(ctx.isDebug(), true);\n  });\n\n  it('use an empty context if the zipkin headers contain invalid ids', () => {\n    let codec = new ZipkinB3TextMapCodec({ urlEncoding: true });\n\n    let carrier = {\n      'x-b3-parentspanid': 'bad-value',\n      'x-b3-spanid': 'another-bad-value',\n      'x-b3-traceid': 'not-a-valid-traceid',\n      'x-b3-sampled': '1',\n      'x-b3-flags': '1',\n      foo: 'bar',\n    };\n\n    let ctx = codec.extract(carrier);\n    assert.isNotOk(ctx.parentIdStr);\n    assert.isNotOk(ctx.spanIdStr);\n    assert.isNotOk(ctx.traceIdStr);\n    assert.equal(ctx.isSampled(), true);\n    assert.equal(ctx.isDebug(), true);\n  });\n  it('correctly inject the zipkin headers into a span context', () => {\n    let codec = new ZipkinB3TextMapCodec({ urlEncoding: true });\n    let carrier = {};\n\n    let ctx = SpanContext.withStringIds('789fed', 'aaafff', '123abc');\n    ctx.flags = constants.DEBUG_MASK | constants.SAMPLED_MASK;\n\n    codec.inject(ctx, carrier);\n    assert.equal(carrier['x-b3-traceid'], '789fed');\n    assert.equal(carrier['x-b3-spanid'], 'aaafff');\n    assert.equal(carrier['x-b3-parentspanid'], '123abc');\n    assert.equal(carrier['x-b3-flags'], '1');\n\n    // > Since Debug implies Sampled, so don't also send \"X-B3-Sampled: 1\"\n    // https://github.com/openzipkin/b3-propagation\n    assert.isUndefined(carrier['x-b3-sampled']);\n  });\n\n  it('should not URL-decode value that has no % meta-characters', () => {\n    let codec = new ZipkinB3TextMapCodec({ urlEncoding: true });\n    codec._decodeURIValue = (value: string) => {\n      throw new URIError('fake error');\n    };\n    assert.strictEqual(codec._decodeValue('abc'), 'abc');\n  });\n\n  it('should not throw exception on bad URL-encoded values', () => {\n    let codec = new ZipkinB3TextMapCodec({ urlEncoding: true });\n    // this string throws exception when passed to decodeURIComponent\n    assert.strictEqual(codec._decodeValue('%EA'), '%EA');\n  });\n\n  it('should decode baggage', () => {\n    let codec = new ZipkinB3TextMapCodec({\n      urlEncoding: true,\n      contextKey: 'trace-context',\n      baggagePrefix: 'baggage-',\n    });\n    let carrier = {\n      'x-b3-parentspanid': '123abc',\n      'x-b3-spanid': 'aaafff',\n      'x-b3-traceid': '789fed',\n      'baggage-some-key': 'some-value',\n      'garbage-in': 'garbage-out',\n    };\n    let ctx = codec.extract(carrier);\n    assert.deepEqual(ctx.baggage, { 'some-key': 'some-value' });\n  });\n\n  it('should encode baggage', () => {\n    let codec = new ZipkinB3TextMapCodec({\n      urlEncoding: true,\n      contextKey: 'trace-context',\n      baggagePrefix: 'baggage-',\n    });\n    let carrier = {};\n\n    let ctx = SpanContext.withStringIds('789fed', 'aaafff', '123abc');\n    ctx = ctx.withBaggageItem('some-key', 'some-value');\n    ctx = ctx.withBaggageItem('another-key', 'another-value');\n\n    codec.inject(ctx, carrier);\n    assert.equal(carrier['baggage-some-key'], 'some-value');\n    assert.equal(carrier['baggage-another-key'], 'another-value');\n  });\n});\n"]}