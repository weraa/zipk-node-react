{"version":3,"sources":["../../test/tchannel_bridge.js"],"names":["constants","describe","BIG_TIMEOUT","reporter","InMemoryReporter","tracer","Tracer","ConstSampler","bridge","TChannelBridge","contextFactory","DefaultContext","originalSpan","startSpan","setBaggageItem","ctx1","setSpan","options","as","mode","context","headers","_","each","o","description","channelEncoding","TChannelAsJSON","TChannelAsThrift","it","server","TChannel","serviceName","timeout","trace","forceTrace","listen","onServerListening","client","clientSubChannel","makeSubChannel","peers","encodedChannel","channel","entryPoint","path","join","__dirname","register","tracedHandler","handleServerReq","req","head","body","callback","assert","equal","Object","keys","length","traceIdStr","getSpan","ok","value","err","res","arg2","arg3","tracedChannel","clientCallback","isNotOk","spans","serverSpan","clientSpan","serverSpanTags","opentracing","Tags","PEER_SERVICE","SPAN_KIND","SPAN_KIND_RPC_SERVER","clientSpanTags","SPAN_KIND_RPC_CLIENT","isOk","TestUtils","hasTags","parentIdStr","spanIdStr","clear","close","done","request","cn","send"],"mappings":"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","file":"tchannel_bridge.js","sourcesContent":["// @flow\n// Copyright (c) 2016 Uber Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n// in compliance with the License. You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software distributed under the License\n// is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n// or implied. See the License for the specific language governing permissions and limitations under\n// the License.\n\nimport _ from 'lodash';\nimport { assert } from 'chai';\nimport * as constants from '../src/constants';\nimport ConstSampler from '../src/samplers/const_sampler';\nimport DefaultContext from '../src/default_context';\nimport path from 'path';\nimport InMemoryReporter from '../src/reporters/in_memory_reporter';\nimport opentracing from 'opentracing';\nimport TestUtils from '../src/test_util.js';\nimport Tracer from '../src/tracer';\nimport TChannel from 'tchannel';\nimport TChannelBridge from '../src/tchannel_bridge.js';\nimport TChannelAsThrift from 'tchannel/as/thrift';\nimport TChannelAsJSON from 'tchannel/as/json';\nimport combinations from './lib/combinations.js';\n\ndescribe('test tchannel span bridge', () => {\n  // BIG_TIMEOUT is useful for debugging purposes.\n  let BIG_TIMEOUT = 15000000;\n  let reporter = new InMemoryReporter();\n  let tracer = new Tracer('test-service', reporter, new ConstSampler(true));\n  let bridge = new TChannelBridge(tracer, {\n    contextFactory: () => {\n      return new DefaultContext();\n    },\n  });\n  let originalSpan = tracer.startSpan('futurama');\n  originalSpan.setBaggageItem('leela', 'fry');\n  let ctx1 = new DefaultContext();\n  ctx1.setSpan(originalSpan);\n\n  let options = combinations({\n    as: ['json', 'thrift'],\n    mode: ['req.send', 'channel.send'],\n    context: [ctx1, null],\n    headers: [{}, null],\n  });\n\n  _.each(options, o => {\n    o.description = `as=${o.as}|mode=${o.mode}`;\n    o.channelEncoding = o.as === 'json' ? TChannelAsJSON : TChannelAsThrift;\n\n    it(o.description + ' spans propagate through tchannel and preserve parent span properties', done => {\n      let server = new TChannel({\n        serviceName: 'server',\n        timeout: BIG_TIMEOUT,\n        // force tracing on in order to prove that overriding works\n        trace: true,\n        forceTrace: true,\n      });\n      // Server calls client channel after it starts listening.\n      server.listen(4040, '127.0.0.1', onServerListening);\n\n      // Create the top level client channel.\n      let client = new TChannel({\n        // force tracing on in order to prove that overriding works\n        trace: true,\n        forceTrace: true,\n      });\n\n      // Create the client subchannel that makes requests.\n      let clientSubChannel = client.makeSubChannel({\n        serviceName: 'server',\n        peers: ['127.0.0.1:4040'],\n      });\n\n      // Wrap the subchannel in an encoding\n      let encodedChannel = o.channelEncoding({\n        channel: clientSubChannel,\n        entryPoint: path.join(__dirname, 'thrift', 'echo.thrift'), // ignored in json case\n      });\n\n      let options: any = {};\n      encodedChannel.register(server, 'Echo::echo', options, bridge.tracedHandler(handleServerReq));\n      function handleServerReq(context, req, head, body, callback) {\n        // headers should not contain $tracing$ prefixed keys, which should be the\n        // only headers used for this test.\n        assert.equal(Object.keys(head).length, 0);\n\n        // assert that the serverSpan is a child of the original span, if context exists\n        // assert that the serverSpan is NOT a child of the original span, if contexts is null\n        assert.equal(\n          originalSpan.context().traceIdStr === req.context.getSpan().context().traceIdStr,\n          !!o.context\n        );\n        callback(null, { ok: true, body: { value: 'some-string' } });\n      }\n\n      function onServerListening(err, res, arg2, arg3) {\n        // Outgoing tchannel call is traced\n        let tracedChannel = bridge.tracedChannel(encodedChannel);\n\n        let clientCallback = (err, res, headers, body) => {\n          assert.isNotOk(err);\n          assert.equal(reporter.spans.length, 2);\n\n          // the first span to be reported is the server span\n          let serverSpan = reporter.spans[0];\n          // the second span to be reported is the client span\n          let clientSpan = reporter.spans[1];\n\n          let serverSpanTags = {};\n          serverSpanTags[opentracing.Tags.PEER_SERVICE] = 'echo';\n          serverSpanTags[opentracing.Tags.SPAN_KIND] = opentracing.Tags.SPAN_KIND_RPC_SERVER;\n          serverSpanTags['as'] = o.as;\n          // TODO(oibe) the port for the client request ephemeral, and I don't know how to get it, or if I can.\n\n          let clientSpanTags = {};\n          clientSpanTags[opentracing.Tags.PEER_SERVICE] = 'server';\n          clientSpanTags[opentracing.Tags.SPAN_KIND] = opentracing.Tags.SPAN_KIND_RPC_CLIENT;\n\n          assert.isOk(TestUtils.hasTags(serverSpan, serverSpanTags));\n          assert.isOk(TestUtils.hasTags(clientSpan, clientSpanTags));\n\n          assert.equal(serverSpan.context().parentIdStr, clientSpan.context().spanIdStr);\n          // If context exists then the following conditions are true\n          // else the following conditons are false\n          assert.equal(serverSpan.context().traceIdStr === originalSpan.context().traceIdStr, !!o.context);\n          assert.equal(clientSpan.context().traceIdStr === originalSpan.context().traceIdStr, !!o.context);\n\n          reporter.clear();\n          server.close();\n          client.close();\n          done();\n        };\n\n        if (o.mode === 'req.send') {\n          let req = tracedChannel.request({\n            serviceName: 'server',\n            headers: { cn: 'echo' },\n            context: o.context,\n            timeout: BIG_TIMEOUT,\n          });\n          req.send('Echo::echo', o.headers, { value: 'some-string' }, clientCallback);\n        } else if (o.mode === 'channel.send') {\n          let req = tracedChannel.channel.request({\n            serviceName: 'server',\n            headers: { cn: 'echo' },\n            context: o.context,\n            timeout: BIG_TIMEOUT,\n          });\n          tracedChannel.send(req, 'Echo::echo', o.headers, { value: 'some-string' }, clientCallback);\n        }\n      }\n    }).timeout(BIG_TIMEOUT);\n  });\n});\n"]}