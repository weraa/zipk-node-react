'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _require = require('../option'),
    None = _require.None,
    Some = _require.Some,
    fromNullable = _require.fromNullable;

var _require2 = require('./sampler'),
    Sampler = _require2.Sampler,
    alwaysSample = _require2.alwaysSample;

var Annotation = require('../annotation');
var Record = require('./record');
var TraceId = require('./TraceId');
var randomTraceId = require('./randomTraceId');

var _require3 = require('../time'),
    now = _require3.now,
    hrtime = _require3.hrtime;

var _require4 = require('../model'),
    Endpoint = _require4.Endpoint;

var isPromise = require('is-promise');

function requiredArg(name) {
  throw new Error('Tracer: Missing required argument ' + name + '.');
}

var Tracer = function () {
  function Tracer(_ref) {
    var _ref$ctxImpl = _ref.ctxImpl,
        ctxImpl = _ref$ctxImpl === undefined ? requiredArg('ctxImpl') : _ref$ctxImpl,
        _ref$recorder = _ref.recorder,
        recorder = _ref$recorder === undefined ? requiredArg('recorder') : _ref$recorder,
        _ref$sampler = _ref.sampler,
        sampler = _ref$sampler === undefined ? new Sampler(alwaysSample) : _ref$sampler,
        _ref$traceId128Bit = _ref.traceId128Bit,
        traceId128Bit = _ref$traceId128Bit === undefined ? false : _ref$traceId128Bit,
        localServiceName = _ref.localServiceName,
        localEndpoint = _ref.localEndpoint;

    _classCallCheck(this, Tracer);

    this.recorder = recorder;
    this.sampler = sampler;
    this.traceId128Bit = traceId128Bit;
    if (localEndpoint) {
      this._localEndpoint = localEndpoint;
    } else {
      this._localEndpoint = new Endpoint({
        serviceName: localServiceName || 'unknown'
      });
    }
    this._ctxImpl = ctxImpl;
    this._defaultTraceId = this.createRootId();
    this._startTimestamp = now();
    this._startTick = hrtime();
  }

  _createClass(Tracer, [{
    key: 'scoped',
    value: function scoped(callback) {
      return this._ctxImpl.scoped(callback);
    }
  }, {
    key: 'letId',
    value: function letId(id, callback) {
      return this._ctxImpl.letContext(id, callback);
    }
  }, {
    key: 'createRootId',
    value: function createRootId() {
      var rootSpanId = randomTraceId();
      var traceId = this.traceId128Bit ? new Some(randomTraceId() + rootSpanId) : None;
      var id = new TraceId({
        traceId: traceId,
        parentId: None,
        spanId: rootSpanId,
        sampled: None,
        flags: 0
      });
      id._sampled = this.sampler.shouldSample(id);
      return id;
    }
  }, {
    key: 'createChildId',
    value: function createChildId() {
      var currentId = fromNullable(this._ctxImpl.getContext());

      var childId = new TraceId({
        traceId: currentId.map(function (id) {
          return id.traceId;
        }),
        parentId: currentId.map(function (id) {
          return id.spanId;
        }),
        spanId: randomTraceId(),
        sampled: currentId.flatMap(function (id) {
          return id.sampled;
        }),
        flags: currentId.map(function (id) {
          return id.flags;
        }).getOrElse(0)
      });
      if (childId.sampled.present === false) {
        childId._sampled = this.sampler.shouldSample(childId);
      }
      return childId;
    }

    // creates a span, timing the given callable, adding any error as a tag
    // if the callable returns a promise, a span stops after the promise resolves

  }, {
    key: 'local',
    value: function local(operationName, callable) {
      var _this = this;

      if (typeof callable !== 'function') {
        throw new Error('you must pass a function');
      }
      return this.scoped(function () {
        var traceId = _this.createChildId();
        _this.setId(traceId);
        _this.recordServiceName(_this._localEndpoint.serviceName);
        _this.recordAnnotation(new Annotation.LocalOperationStart(operationName));

        var result = void 0;
        try {
          result = callable();
        } catch (err) {
          _this.recordBinary('error', err.message ? err.message : err.toString());
          _this.recordAnnotation(new Annotation.LocalOperationStop());
          throw err;
        }

        // Finish the span on a synchronous success
        if (!isPromise(result)) {
          _this.recordAnnotation(new Annotation.LocalOperationStop());
          return result;
        }

        if (!traceId.sampled.getOrElse(false)) {
          return result; // no need to stop as it was never started
        }

        // At this point we know we are sampled. Explicitly record against the ID
        var explicitRecord = function explicitRecord(annotation) {
          return _this.recorder.record(new Record({
            traceId: traceId,
            timestamp: now(_this._startTimestamp, _this._startTick),
            annotation: annotation
          }));
        };

        // Ensure the span representing the promise completes
        return result.then(function (output) {
          explicitRecord(new Annotation.LocalOperationStop());
          return output;
        }).catch(function (err) {
          var message = err.message ? err.message : err.toString();
          explicitRecord(new Annotation.BinaryAnnotation('error', message));
          explicitRecord(new Annotation.LocalOperationStop());
          throw err;
        });
      });
    }
  }, {
    key: 'setId',
    value: function setId(traceId) {
      this._ctxImpl.setContext(traceId);
    }
  }, {
    key: 'recordAnnotation',
    value: function recordAnnotation(annotation) {
      var _this2 = this;

      this.id.sampled.ifPresent(function (sampled) {
        // sampled present is different than sampled == true
        if (!sampled) return;
        _this2.recorder.record(new Record({
          traceId: _this2.id,
          timestamp: now(_this2._startTimestamp, _this2._startTick),
          annotation: annotation
        }));
      });
    }
  }, {
    key: 'recordMessage',
    value: function recordMessage(message) {
      this.recordAnnotation(new Annotation.Message(message));
    }
  }, {
    key: 'recordServiceName',
    value: function recordServiceName(serviceName) {
      this.recordAnnotation(new Annotation.ServiceName(serviceName));
    }
  }, {
    key: 'recordRpc',
    value: function recordRpc(name) {
      this.recordAnnotation(new Annotation.Rpc(name));
    }
  }, {
    key: 'recordClientAddr',
    value: function recordClientAddr(ia) {
      this.recordAnnotation(new Annotation.ClientAddr(ia));
    }
  }, {
    key: 'recordServerAddr',
    value: function recordServerAddr(ia) {
      this.recordAnnotation(new Annotation.ServerAddr(ia));
    }
  }, {
    key: 'recordLocalAddr',
    value: function recordLocalAddr(ia) {
      this.recordAnnotation(new Annotation.LocalAddr(ia));
    }
  }, {
    key: 'recordBinary',
    value: function recordBinary(key, value) {
      this.recordAnnotation(new Annotation.BinaryAnnotation(key, value));
    }
  }, {
    key: 'writeIdToConsole',
    value: function writeIdToConsole(message) {
      /* eslint-disable no-console */
      console.log(message + ': ' + this.id.toString());
    }
  }, {
    key: 'id',
    get: function get() {
      return this._ctxImpl.getContext() || this._defaultTraceId;
    }
  }, {
    key: 'localEndpoint',
    get: function get() {
      return this._localEndpoint;
    }
  }]);

  return Tracer;
}();

module.exports = Tracer;